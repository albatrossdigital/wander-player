<!DOCTYPE html>
<html>
<head>
    <meta charset='utf-8' />
    <title></title>
    <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />
    <script src='https://api.tiles.mapbox.com/mapbox-gl-js/v0.14.0/mapbox-gl.js'></script>
    <link href='https://api.tiles.mapbox.com/mapbox-gl-js/v0.14.0/mapbox-gl.css' rel='stylesheet' />
    <script src='https://code.jquery.com/jquery-2.2.0.min.js'></script>
    <style>
        body { margin:0; padding:0; }
        #map { position:absolute; top:0; bottom:0; width:100%; }
    </style>
</head>
<body>

<style>
.map-overlay-container {
    position: absolute;
    width: 25%;
    top: 0;
    left: 0;
    padding: 10px;
    z-index: 1;
}

.map-overlay {
    font: 12px/20px 'Helvetica Neue', Arial, Helvetica, sans-serif;
    background-color: #fff;
    border-radius: 3px;
    padding: 10px;
    box-shadow:0 1px 2px rgba(0,0,0,0.20);
}

.map-overlay h2,
.map-overlay p {
    margin: 0 0 10px;
}

img {
    max-width: 400px;
}
</style>

<div id='map'></div>

<div class='map-overlay-container'>
  <div class='map-overlay'>
    <h2 id='location-title'></h2>
    <p id='location-description'></p>
    <small>Text credit: <a href='http://www.nycgo.com/neighborhoods'>nycgo.com</a></small>
  </div>
</div>

<script>




jQuery( document ).ready(function( $ ) {
    var data;
    var map;
    var linespeed = 1; // coords to add per sec
    var segment = {};
    var title = $('#location-title');
    var description = $('#location-description');
    
    $.getJSON('json/example.json').success(function(json) {

        data = json;

        data.markers = [];
        data.route = [];
        var i = 0;
        // Separate the markers from the route
        for (var j= 0; j < data.features.length; ++j) {
          var item = data.features[j];
          if (item.geometry.type == 'Point') {
            data.markers.push(item);
          }
          else {
            item.geometry.coordinates = item.geometry.coordinates.reverse();
            data.route = item;
          }
        }

        // Figure out the key in the route for each marker
        for (var i=0, n=data.markers.length; i<n; i++) {
          var route = {
            end: closestKey(data.markers[i].geometry.coordinates, data.route.geometry.coordinates)
          }
          if ((i > 0) && data.markers[i-1] != undefined) {
            route.start = closestKey(data.markers[i-1].geometry.coordinates, data.route.geometry.coordinates);
          }
          data.markers[i].properties.route = route;
        }

        mapboxgl.accessToken = 'pk.eyJ1IjoiYWxiYXRyb3NzZGlnaXRhbCIsImEiOiI1cVUxbUxVIn0.SqKOVeohLfY0vfShalVDUw';
        map = new mapboxgl.Map({
            container: 'map',
            style: 'mapbox://styles/albatrossdigital/cikgiezpo003fapm5vadl6owu',
            center: data.markers[0].geometry.coordinates,
            maxZoom: 16,
            minZoom: 9,
            zoom: 9.68
        });


        function highlightBorough(code) {
            // Only show the polygon feature that cooresponds to `borocode` in the data
            map.setFilter('highlight', ["==", "borocode", code]);
        }

        function playback(index) {
            var marker = data.markers[index];
            title.textContent = '';//locations[index].title;
            description.html(marker.properties.content);

            //highlightBorough(locations[index].id ? locations[index].id : '');

            // Animate the map position based on camera properties
            var next = data.markers[index+1] != undefined ? data.markers[index+1].geometry.coordinates : data.markers[0].geometry.coordinates;
            map.flyTo({
                center: marker.geometry.coordinates,
                bearing:getBearing(marker.geometry.coordinates[1], marker.geometry.coordinates[0], next[1], next[0]),
                zoom: 13 + Math.random()*3,
                pitch: 50 + Math.random()*20,
            });

            // Draw the link
            segment = marker.properties.route;
            linespeed = (segment.end - segment.start) / 1;
            updateLine(0);            

            map.once('moveend', function() {
                // Duration the slide is on screen after interaction
                window.setTimeout(function() {
                    // Increment index
                    index = (index + 1 === data.markers.length) ? 0 : index + 1;
                    playback(index);
                }, 3000); // After callback, show the location for 3 seconds.
            });
        }

        // Display the last title/description first
        //title.textContent = locations[locations.length - 1].title;
        //description.textContent = locations[locations.length - 1].description;

        map.on('load', function() {

            // Polygon fill for each borough of new york city.
            // Used to highlight when its borough is active.


            /*map.addLayer({
                "id": "highlight",
                "type": "fill",
                "source": "boroughs",
                "source-layer": "original",
                "paint": {
                    "fill-color": "#fd6b50",
                    "fill-opacity": 0.25
                },
                "filter": ["==", "borocode", ""]
            }, 'neighborhood_small_label'); // Place polygon under the neighborhood labels.
*/  
            map.addSource("route", {
                "type": "geojson",
                "data": data.route
            });

            map.addLayer({
                "id": "route",
                "type": "line",
                "source": "route",
                "layout": {
                    "line-join": "round",
                    "line-cap": "round"
                },
                "paint": {
                    "line-color": "#888",
                    "line-width": 4,
                    "line-opacity": .3
                }
            });

            map.addSource("completed", {
                "type": "geojson",
                "data": completedLine(0)
            });

            map.addLayer({
                "id": "completed",
                "type": "line",
                "source": "completed",
                "layout": {
                    "line-join": "round",
                    "line-cap": "round"
                },
                "paint": {
                    "line-color": "#0E1EFF",
                    "line-width": 4,
                    "line-opacity": 1
                }
            });

            map.addSource("markers", {
                "type": "geojson",
                "data": {
                    "type": "FeatureCollection",
                    "features":  data.markers
                }
            });

            map.addLayer({
                "id": "markers",
                "type": "symbol",
                "source": "markers",
                "layout": {
                    "icon-image": "monument-15",
                    "text-font": ["Open Sans Semibold", "Arial Unicode MS Bold"],
                    "text-offset": [0, 0.6],
                    "text-anchor": "top"
                }
            });

            

            // Start the playback animation for each borough
            playback(0);
            //updateLine(0);
        });

        




    }); // end

    var j = 0;
    function updateLine(timestamp) {
        var i = segment.start + Math.floor(linespeed*timestamp/1000);
        if (i <= segment.end) {
            // Update the data to a new position based on the animation timestamp. The
            // divisor in the expression `timestamp / 1000` controls the animation speed.
            if (j != i) {
              map.getSource('completed').setData(completedLine(i));
            }
            j = i;

            // Request the next frame of the animation.
            requestAnimationFrame(updateLine);
        }
        
    }



    function completedLine(completed) {
        var out = {
            "type": "LineString",
            "coordinates": []
        };
        for (i=0; i<=completed; i++) {
            out.coordinates.push(data.route.geometry.coordinates[i]);
        }
        return out;
    }


        

    function setPaddingRight() {
      if (window.innerWidth <= 640) {
        return 0;
      }
      else {
        return parseInt(window.innerHeight*.5);
      }
    }


    // copeied from leaflet.geometryutil.js closest fxn
    function closestKey(latlng, latlngs) {
      var mindist = 10000000;
      var result = null;
      for(var i = 0, n = latlngs.length; i < n; i++) {
        var distance = getDistance(latlngs[i][1], latlngs[i][0], latlng[1], latlng[0]);
        if (distance < mindist) {
            mindist = distance;
            //result = ll;
            result = i;
        }
      }
      return result;
    }

    // From http://stackoverflow.com/questions/18883601/function-to-calculate-distance-between-two-coordinates-shows-wrong
    function getDistance(lat1, lon1, lat2, lon2) 
    {
      var R = 6371; // km
      var dLat = toRad(lat2-lat1);
      var dLon = toRad(lon2-lon1);
      var lat1 = toRad(lat1);
      var lat2 = toRad(lat2);

      var a = Math.sin(dLat/2) * Math.sin(dLat/2) +
        Math.sin(dLon/2) * Math.sin(dLon/2) * Math.cos(lat1) * Math.cos(lat2); 
      var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); 
      var d = R * c;
      return d;
    }

    // Converts numeric degrees to radians
    function toRad(Value) 
    {
        return Value * Math.PI / 180;
    }


    // From http://gis.stackexchange.com/questions/29239/calculate-bearing-between-two-decimal-gps-coordinates
    function radians(n) {
      return n * (Math.PI / 180);
    }
    function degrees(n) {
      return n * (180 / Math.PI);
    }

    function getBearing(startLat,startLong,endLat,endLong){
      startLat = radians(startLat);
      startLong = radians(startLong);
      endLat = radians(endLat);
      endLong = radians(endLong);

      var dLong = endLong - startLong;

      var dPhi = Math.log(Math.tan(endLat/2.0+Math.PI/4.0)/Math.tan(startLat/2.0+Math.PI/4.0));
      if (Math.abs(dLong) > Math.PI){
        if (dLong > 0.0)
           dLong = -(2.0 * Math.PI - dLong);
        else
           dLong = (2.0 * Math.PI + dLong);
      }

      return (degrees(Math.atan2(dLong, dPhi)) + 360.0) % 360.0;
    }



    function getCompleted(current, start, end) {
      return (current-start)/(end-start);
    }


});



</script>

</body>
</html>
</html>